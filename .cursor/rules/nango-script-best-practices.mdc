---
ruleType: always
alwaysApply: true
---

# Writing Integration Scripts

## Configuration - nango.yaml

- If `sync_type: full`, then the sync should also have `track_deletes: true`
- If the sync requires metadata, then the sync should be set to `auto_start: false`. The metadata should be documented as an input in the nango.yaml
- Scopes should be documented

```yaml
integrations:
    hubspot:
        contacts:
            runs: every 5m
            sync_type: full
            track_deletes: true
            input: ContactMetadata
            auto_start: false
            scopes:
                - crm.objects.contacts.read
            description: A super informative and helpful description that tells us what the sync does.
models:
    ContactMetadata:
        # ... model definition
```

## Scripts

### General Guidelines

- Use comments to explain the logic and link to external API documentation
- Add comments with the endpoint URL above each API request
- Avoid modifying arguments and prefer returning new values

### Types and Models

- Add a `types.ts` file which contains typed third party API responses
  - Types in `types.ts` should be prefixed with the integration name (e.g., `GoogleUserResponse`, `AsanaTaskResponse`) as they represent the raw API responses
  - This helps avoid naming conflicts with the user-facing types defined in `nango.yaml`
- Models defined in `nango.yaml` are automatically generated into a `models.ts` file
  - Always import these types from the models file instead of redefining them in your scripts

```typescript
// ❌ Don't define interfaces that match nango.yaml models
interface TaskResponse {
    tasks: Task[];
}

// ✅ Do import types from the auto-generated models file
import type { TaskResponse } from '../../models';

// ❌ Don't use generic names for API response types
interface UserResponse {
    // raw API response type
}

// ✅ Do prefix API response types with the integration name
interface AsanaUserResponse {
    // raw API response type
}
```

### API Calls and Configuration

- Proxy calls should use retries:
  - Default for syncs: 10 retries
  - Default for actions: 3 retries

```typescript
const proxyConfig: ProxyConfiguration = {
    retries: 10,
    // ... other config
};
```

- Use `await nango.log` for logging (avoid `console.log`)
- Use the `params` property instead of appending params to the endpoint
- Use the built-in `nango.paginate` wherever possible:

```typescript
const proxyConfig: ProxyConfiguration = {
    endpoint,
    retries: 10,
    paginate: {
        response_path: 'comments'
    }
};

for await (const pages of nango.paginate(proxyConfig)) {
    // ... handle pages
}
```

- Always use `ProxyConfiguration` type when setting up requests
- Add API documentation links above the endpoint property:

```typescript
const proxyConfig: ProxyConfiguration = {
    // https://www.great-api-docs.com/endpoint
    endpoint,
    retries: 10,
};
```

### Code Generation

Generate zod models at the integration level:
```bash
npm run generate:zod --integration=${INTEGRATION}
```

## Validation

- Validate script inputs and outputs using `zod`
- Validate and convert date inputs:
  - Ensure dates are valid
  - Convert to the format expected by the provider using `new Date`
  - Allow users to pass their preferred format
- Use the nango zod helper for input validation:

```typescript
const parseResult = await nango.zodValidateInput({
    zodSchema: documentInputSchema,
    input,
});
```

## Syncs

- `fetchData` must be the default export at the top of the file
- Always paginate requests to retrieve all records
- Avoid parallelizing requests (defeats retry policy and rate limiting)
- Do not wrap syncs in try-catch blocks (Nango handles error reporting)
- Use dedicated mapper functions for data transformation:
  - Place shared mappers in a `mappers` directory
  - Name files as `mappers/to-${entity}` (e.g., `mappers/to-employee.ts`)

```typescript
import { toEmployee } from '../mappers/to-employee.js';

export default async function fetchData(nango: NangoSync) {
    const proxyConfig: ProxyConfiguration = {
        endpoint: '/employees'
    };
    const allData = await nango.get(proxyConfig);
    return toEmployee(allData);
}
```

- Avoid type casting to leverage TypeScript benefits:

```typescript
// ❌ Don't use type casting
return {
    user: userResult.records[0] as HumanUser,
    userType: 'humanUser'
};

// ✅ Do use proper type checks
if (isHumanUser(userResult.records[0])) {
    return {
        user: userResult.records[0],
        userType: 'humanUser'
    };
}
```

- For incremental syncs, use `nango.lastSyncDate`

## Actions

- `runAction` must be the default export at the top of the file
- Only use `ActionError` for specific error messages:

```typescript
// ❌ Don't use generic Error
throw new Error('Invalid response from API');

// ✅ Do use nango.ActionError with a message
throw new nango.ActionError({
    message: 'Invalid response format from API'
});
```

- Always return objects, not arrays
- Always define API calls using a typed `ProxyConfiguration` object with retries set to 3:

```typescript
// ❌ Don't make API calls without a ProxyConfiguration
const { data } = await nango.get({
    endpoint: '/some-endpoint',
    params: { key: 'value' }
});

// ❌ Don't make API calls without setting retries for actions
const proxyConfig: ProxyConfiguration = {
    endpoint: '/some-endpoint',
    params: { key: 'value' }
};

// ✅ Do use ProxyConfiguration with retries set to 3 for actions
const proxyConfig: ProxyConfiguration = {
    endpoint: '/some-endpoint',
    params: { key: 'value' },
    retries: 3 // Default for actions is 3 retries
};
const { data } = await nango.get(proxyConfig);
```

```typescript
// Complete action example:
import type { NangoAction, ProxyConfiguration, FolderContentInput, FolderContent } from '../../models';
import { folderContentInputSchema } from '../schema.zod.js';

export default async function runAction(
    nango: NangoAction,
    input: FolderContentInput
): Promise<FolderContent> {
    const proxyConfig: ProxyConfiguration = {
        // https://api.example.com/docs/endpoint
        endpoint: '/some-endpoint',
        params: { key: 'value' },
        retries: 3 // Default for actions is 3 retries
    };
    
    const { data } = await nango.get(proxyConfig);
    return { result: data };
}
```

## Testing

### Running Tests

Test scripts directly against the third-party API using dryrun:

```bash
npm run dryrun -- ${INTEGRATION} ${scriptName} ${connectionId}
```

Example:
```bash
npm run dryrun -- google-calendar settings g
```

### Dryrun Options

- `--auto-confirm`: Skip prompts and show all output
```bash
npm run dryrun -- google-calendar settings g --auto-confirm
```

- `--save-responses`: Save API responses for test fixtures
```bash
npm run dryrun -- google-calendar settings g --save-responses
```

- Combine options:
```bash
npm run dryrun -- google-calendar settings g --save-responses --auto-confirm
```

### Test Generation

After saving responses, generate tests:
```bash
npm run generate:tests --integration=${INTEGRATION}
```

This will:
1. Use saved API responses as test fixtures
2. Create test files in the `tests` directory
3. Set up proper mocking and assertions
4. Test both data saving and deletion

## Script Helpers

-   `npm run move:integrations` moves all the integrations into a `nango-integrations` directory. Accepts an optional `--integration=${INTEGRATION}` flag
-   `npm run undo:move:integrations` undo the move of integrations into a `nango-integrations` directory
-   `npm run lint-moved-integrations` lint all the integrations after moving them to the to the `nngo-integrations` directory
-   `npm run generate:zod` generate zod models for all integrations. Accepts an optional `--integration=${INTEGRATION}` flag. Doesn't overwrite existing zod file but if `--force` is passed it will
-   `npm run compile` moves all the integrations into a `nango-integrations` directory and attempts to compile the code. Accepts an optional `--integration=${INTEGRATION} flag`
-   `npm run prettier-format` formats the typescript files according to the prettier configuration
-   `npm run generate:tests` generate test files for all integrations. Accepts an optional `--integration=${INTEGRATION}` flag
-   `npm run dryrun -- ${INTEGRATION} ${scriptName} ${connectionId} -e ${Optional environment}`
