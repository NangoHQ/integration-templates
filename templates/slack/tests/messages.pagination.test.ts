import { describe, expect, test } from 'vitest';
// @ts-ignore - Schema file is generated by Nango
import type { SlackMessage, SlackMessageReply, SlackMessageReaction } from '../.nango/schema.js';
import fetchData from '../syncs/messages.js';

describe('Slack Messages Pagination', () => {
    test('should configure cursor-based pagination correctly', async () => {
        const mockChannel = { id: 'C123' };
        const mockMessage = {
            ts: '1234567890.123',
            type: 'message',
            text: 'Hello world',
            user: 'U123',
            thread_ts: null,
            reactions: [
                {
                    name: 'thumbsup',
                    users: ['U123', 'U456']
                }
            ]
        };

        let channelsConfig: any = null;
        let messagesConfig: any = null;
        let savedMessages: SlackMessage[] = [];
        let savedReactions: SlackMessageReaction[] = [];
        let metadata: any = {};

        const nango = {
            paginate: async function* <T>(config: any) {
                if (config.endpoint === 'users.conversations') {
                    channelsConfig = config;
                    yield [mockChannel];
                } else if (config.endpoint === 'conversations.history') {
                    messagesConfig = config;
                    yield [mockMessage];
                } else {
                    yield [];
                }
            },
            batchSave: async (items: any[], model: string) => {
                if (model === 'SlackMessage') {
                    savedMessages = items;
                } else if (model === 'SlackMessageReaction') {
                    savedReactions = items;
                }
            },
            getMetadata: async () => metadata,
            setMetadata: async (newMetadata: any) => {
                metadata = newMetadata;
            },
            log: async (message: string) => {}
        };

        await fetchData.exec(nango as any);

        // Verify channels pagination config
        expect(channelsConfig).toBeDefined();
        expect(channelsConfig.endpoint).toBe('users.conversations');
        expect(channelsConfig.paginate).toEqual({
            limit: 200,
            response_path: 'channels'
        });
        expect(channelsConfig.retries).toBe(10);

        // Verify messages pagination config
        expect(messagesConfig).toBeDefined();
        expect(messagesConfig.endpoint).toBe('conversations.history');
        expect(messagesConfig.params.channel).toBe('C123');
        expect(messagesConfig.paginate).toEqual({
            limit: 15,
            response_path: 'messages'
        });
        expect(messagesConfig.retries).toBe(10);

        // Verify saved messages
        expect(savedMessages).toHaveLength(1);
        expect(savedMessages[0]).toMatchObject({
            ts: '1234567890.123',
            channel_id: 'C123',
            text: 'Hello world',
            user_id: 'U123'
        });

        // Verify saved reactions
        expect(savedReactions).toHaveLength(2);
        expect(savedReactions[0].reaction_name).toBe('thumbsup');
        expect(savedReactions[1].reaction_name).toBe('thumbsup');
    });

    test('should handle empty pages', async () => {
        let channelsConfig: any = null;

        const nango = {
            paginate: async function* <T>(config: any) {
                channelsConfig = config;
                yield [];
            },
            batchSave: async (items: any[], model: string) => {},
            getMetadata: async () => ({}),
            setMetadata: async (metadata: any) => {},
            log: async (message: string) => {}
        };

        await fetchData.exec(nango as any);

        expect(channelsConfig).toBeDefined();
        expect(channelsConfig.paginate.limit).toBe(200);
    });

    test('should handle pagination errors', async () => {
        const nango = {
            paginate: async function* <T>(config: any) {
                throw new Error('Pagination failed');
            },
            batchSave: async (items: any[], model: string) => {},
            getMetadata: async () => ({}),
            setMetadata: async (metadata: any) => {},
            log: async (message: string) => {}
        };

        await expect(fetchData.exec(nango as any)).rejects.toThrow('Pagination failed');
    });
});
